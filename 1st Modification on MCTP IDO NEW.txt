// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";


/**
 * @title MetaCraftIDO
 *
 */

contract MetaCraftIDO is ReentrancyGuard {
    
    using SafeERC20 for IERC20;
    
    string public name;
    address private owner;
    uint256 public chainId;
    address payable public withdrawAddress;
    address public projectCoinAddress;//raisecoinaddress
    address public investCoinAddress; //moneyaddress
    uint256 public investTargetAmount;  //BUSD or USDT target Amount;
    uint256 public projectCoinPrice=1e16; //0.01; price
    uint256 public startTimestamp = 1711035000;
    uint256 public endSellTimestamp = 1711040000;
    uint256 public protectTimestamp = 1711045000;
    uint256 public claimTimestamp = 1711050000;

    Investor []  public investors;  //participants investors.length;
    uint256 public decimals=18;
    //bool public isIssued = false;
  
    
    
    uint public raiseStatus=0; // 0-Not begin; 1-isSelling;2-isWatting; 3- isProtecting; 4- isClaiming;
    
   
    address public publicKey = address(0xEe8b45a0c599e8E6512297f99687BF5FE3359147);
    mapping(address=>uint256) public investedAmount;  //user Invested Amount of raise Coin /USDT or BUSD
    mapping(address=>uint256) public claimedAmount;  // User Claimed Amount of Project Coin
    mapping(address=>uint256) public refundedAmount; //user Refunded Amount of raise Coin
    mapping(address=>uint256) public projectCoinAmount; // IDO Project Coin Amount
    //VIP level logicals:
    //[tokenAddress][userLevel--1,2,3]==>uint256 amount
    mapping(address=>mapping(uint8 =>uint256)) public VIPAmount;
    //VIPLimit[userLevel]==>limit
    mapping(uint8=>uint256) public VIPLimit;
    // VIPPerLimit[userLevel] => Limit Percent of userLevel
    mapping(uint8=>uint256) public VIPPerLimit;
    // userVIPAmount[useraddress][tokenAddress][1] ==> user amount of VIP useraddress
    mapping(address=>mapping(address=>mapping(uint8 =>uint256))) public userVIPAmount;

    struct Investor {
        address investCoinAddress; //usdt or BUSD contract address;
        address payable investorAddress;
        uint256 investedCoinAmount;  // user invest USDT or BUSD amount
        uint256 refundedCoinAmount;  // user Refund USDT or BUSD amount from IDO
        uint256 claimedProjectCoinAmount; //projectCoin Amount
        uint256 investedAt;
        uint256 refundedAt;
        uint256 claimedAt;
    }
    mapping(address => uint256) private investorIndex;

    uint constant MIN_SIGNATURES = 3;
    uint private _transactionIdx;

    struct projectInfoGet {
        uint256 price;
        uint256 targetAmount;
        uint256 currentAmount;
        uint256 participants;
        address raiseCoinAddress;
        address moneyAddress;
        uint256 vip1Allocation;
        uint256 vip2Allocation;
        uint256 vip3Allocation;
        uint256 vip1Percent;
        uint256 vip2Percent;
        uint256 vip3Percent;
        uint256 startTime;
        uint256 endSellTime;
        uint256 protectTime;
        uint256 claimTime;
        uint raiseStatus;
        uint256 vip1CurrentAmount;
        uint256 vip2CurrentAmount;
        uint256 vip3CurrentAmount;
    }

    struct projectInfoSet {
        uint256 price;
        uint256 targetAmount;
        address raiseCoinAddress;
        address moneyAddress;
        uint256 vip1Allocation;
        uint256 vip2Allocation;
        uint256 vip3Allocation;
        uint256 vip1Percent;
        uint256 vip2Percent;
        uint256 vip3Percent;
        uint256 startTime;
        uint256 endSellTime;
        uint256 protectTime;
        uint256 claimTime;
        uint raiseStatus;
    }

    mapping(address => Investor) public investorByAddress;

    /**
     */
    event IDOEvents(
        uint256 timeStamp,
        address eventSender,         
        string  eventName
    );
    event IDOStatusChange(
       address indexed itemToken,
       uint256 indexed tokenAmount, 
       address indexed eventSender,
	   string status
	   );

    event TransactionReadyForExecution(
        address itemToken,
        uint256 timestamp,
        uint transactionId
    );

    event TransactionCreated(address withdrawAddress,  uint256 timestamp, uint256 transactionId);
    event TransactionCompleted(address withdrawAddress,  uint256 timestamp, uint256 transactionId);
    event TransactionSigned(address by, uint transactionId);

    struct Transaction {
      address withdrawAddress_;
      uint8 signatureCount;
      uint256 readyForExecutionTimestamp; 
      uint256 timestamp;
    }
    struct TxAddOwner {
      address owner;
      uint8 signatureCount;
      uint256 timestamp;
    }

     struct TxDelOwner {
      address owner;
      uint8 signatureCount;
      uint256 timestamp;
    }

    mapping(address => uint8) private _owners;
    mapping ( uint=>mapping(address => uint8)) signatures;
    mapping (uint => Transaction) private _transactions;
    uint[] private _pendingTransactions;
    uint256 public observationPeriod = 24 ;
    uint256 public maxPendingTime = 96;

    mapping (uint => TxAddOwner) private _txaddowners;
    mapping (uint => TxDelOwner) private _txdelowners;

    modifier validOwner() {
        require(_owners[msg.sender] == 1, "not Authorized Mulsig User !");
        _;
    }
    function  deleteMaxPendingTx()
    private 
    {
         require(_pendingTransactions.length <= 1,"has pending txs! Please sign them first");   
         
         if(_pendingTransactions.length == 1 ){
                uint txId = _pendingTransactions[0];
                Transaction storage pendingwithdrawTx = _transactions[txId];
                TxAddOwner storage pendingaddTx = _txaddowners[txId];
                TxDelOwner storage pendingdelTx = _txdelowners[txId];
                //for withdraw Txs
                if (pendingwithdrawTx.timestamp > 0 ){
                    if(block.timestamp - pendingwithdrawTx.timestamp > maxPendingTime){
                         deleteTransaction(txId);
                    } else revert("has pending txs yet! Please sign them first");
                   
                }
                //for add user Txs
                if (pendingaddTx.timestamp> 0 ){
                    if(block.timestamp - pendingaddTx.timestamp > maxPendingTime) {
                         deleteAddUserTx(txId);
                    }else revert("has pending txs yet! Please sign them first");
                   
                } 
                //for del user Txs
                if (pendingdelTx.timestamp > 0 ){
                    if (block.timestamp - pendingdelTx.timestamp > maxPendingTime){
                        deleteDelUserTx(txId);
                    }else revert("has pending txs yet! Please sign them first");
                    
                }

            }

    }
    function addOwner(address _owner)
        public 
        {
            require(msg.sender==owner,"Only owner can set Parameters");
            require(_owner != address(0),"Zero Address Error!");
            

            deleteMaxPendingTx();

            uint256 transactionId = _transactionIdx++;
            TxAddOwner memory txOwner;
            
            txOwner.owner = _owner;
            txOwner.timestamp = block.timestamp;
            txOwner.signatureCount = 0;
            _txaddowners[transactionId]=txOwner;
            _pendingTransactions.push(transactionId);

            emit TransactionCreated(_owner,  block.timestamp, transactionId);
            emit IDOEvents(block.timestamp,msg.sender, "AddValieOwner");
    }

    function removeOwner(address _owner)
        
        public {
            require(msg.sender==owner,"Only owner can set Parameters");
            require(_owner != address(0),"Zero Address Error!");
           

            deleteMaxPendingTx();


            uint256 transactionId = _transactionIdx++;
            TxDelOwner memory txOwner;
            
            txOwner.owner = _owner;
            txOwner.timestamp = block.timestamp;
            txOwner.signatureCount = 0;
            _txdelowners[transactionId]=txOwner;
            _pendingTransactions.push(transactionId);
           
            emit TransactionCreated(_owner,  block.timestamp, transactionId);
            emit IDOEvents(block.timestamp,msg.sender, "RemoveValieOwner");
    }
    
    function signUserAdd(uint transactionId)
      validOwner
      public {

            TxAddOwner storage transaction = _txaddowners[transactionId];

            // Transaction must exist
            require(address(0) != transaction.owner,  "Fee To Zero Addresses!");
            // Creator cannot sign the transaction
            require(msg.sender !=transaction.owner , "Can't Sign Self!" );
            // Cannot sign a transaction more than once
            require(signatures[transactionId][msg.sender] != 1, "Can't Sign Again with the same Account!");
            signatures[transactionId][msg.sender] = 1;

            transaction.signatureCount++;
            transaction.timestamp= block.timestamp;

            emit TransactionSigned(msg.sender, transactionId);
           
            if (transaction.signatureCount >= MIN_SIGNATURES) {
                    _owners[(transaction.owner)]=1;
                    emit TransactionCompleted(transaction.owner, block.timestamp, transactionId);
                    deleteAddUserTx(transactionId);
            }
    }
    function deleteAddUserTx(uint transactionId)
        validOwner
        private {
            TxAddOwner memory transaction = _txaddowners[transactionId];
            require(transaction.timestamp > 0, "transaction not exist!");
           
            uint256 txLength = _pendingTransactions.length;
            for (uint256 i = 0; i < txLength; i++) {
                if (_pendingTransactions[i] == transactionId) {
                    
                    _pendingTransactions[i] = _pendingTransactions[txLength - 1];
                   
                    _pendingTransactions.pop();
                    break;
                }
            }
            delete _txaddowners[transactionId];
    }
    function signUserDel(uint transactionId)
      validOwner
      public {

            TxDelOwner storage transaction = _txdelowners[transactionId];

            // Transaction must exist
            require(address(0) != transaction.owner,  "Fee To Zero Addresses!");
            // Creator cannot sign the transaction
            require(msg.sender !=transaction.owner , "Can't Sign Self!" );
            // Cannot sign a transaction more than once
            require(signatures[transactionId][msg.sender] != 1, "Can't Sign Again with the same Account!");
          
            signatures[transactionId][msg.sender] = 1;

            transaction.signatureCount++;
            transaction.timestamp= block.timestamp;

            emit TransactionSigned(msg.sender, transactionId);
           
            if (transaction.signatureCount >= MIN_SIGNATURES) {
                    _owners[transaction.owner]=0;
                
                    emit TransactionCompleted(transaction.owner, block.timestamp, transactionId);
                    deleteDelUserTx(transactionId);
            }
    }
   function deleteDelUserTx(uint transactionId)
        validOwner
        private {
            TxDelOwner memory transaction = _txdelowners[transactionId];
            require(transaction.timestamp > 0, "transaction not exist!");
           
            uint256 txLength = _pendingTransactions.length;
            for (uint256 i = 0; i < txLength; i++) {
                if (_pendingTransactions[i] == transactionId) {
                    
                    _pendingTransactions[i] = _pendingTransactions[txLength - 1];
                   
                    _pendingTransactions.pop();
                    break;
                }
            }
            delete _txdelowners[transactionId];
    }

    constructor (string memory projectName, 
    uint256 targetAmount_, 
    address investCoinAddress_, 
    address publicKey_)
    {
        owner = msg.sender;
       	name = projectName;
        investTargetAmount = targetAmount_ * 10 ** decimals;
        
        withdrawAddress = payable(msg.sender);

        investCoinAddress = investCoinAddress_;
        publicKey = publicKey_;
        
        VIPLimit[1] = 100;
        VIPLimit[2] = 500;
        VIPLimit[3] = 1000;

        VIPPerLimit[1] = 20;
        VIPPerLimit[2] = 30;
        VIPPerLimit[3] = 50;

        chainId = block.chainid;

    }
    function getPendingTransactions()
      view
      public
      returns (uint[] memory) {
      return _pendingTransactions;
    }

    function signTransaction(uint transactionId)
      validOwner
      public {

            Transaction storage transaction = _transactions[transactionId];

            // Transaction must exist
            require(address(0) != transaction.withdrawAddress_,  "Fee To Zero Addresses!");
            // Creator cannot sign the transaction
            require(msg.sender !=transaction.withdrawAddress_ , "Can't Sign Self!" );
            // Cannot sign a transaction more than once
            require(signatures[transactionId][msg.sender] != 1, "Can't Sign Again with the same Account!");
            // can not sign within once within 24 hours
            require(block.timestamp - transaction.timestamp >= 24 hours,"Time Lockin for 48 Hours for at Least 2 signers !");

            signatures[transactionId][msg.sender] = 1;

            transaction.signatureCount++;
            transaction.timestamp= block.timestamp;

            emit TransactionSigned(msg.sender, transactionId);
            // at least Sign twice, this will larger than 48 Hours
            if (transaction.signatureCount >= MIN_SIGNATURES) {
                    withdrawAddress = payable(transaction.withdrawAddress_);
                
                    emit TransactionCompleted(transaction.withdrawAddress_, block.timestamp, transactionId);
                    deleteTransaction(transactionId);
            }
    }

    function deleteTransaction(uint transactionId)
        validOwner
        public {
            uint8 replace = 0;
            for(uint i = 0; i < _pendingTransactions.length; i++) {
                if (1 == replace) {
                _pendingTransactions[i-1] = _pendingTransactions[i];
                } else if (transactionId == _pendingTransactions[i]) {
                replace = 1;
                }
            }
            delete _pendingTransactions[_pendingTransactions.length - 1];
            _pendingTransactions.pop();
            delete _transactions[transactionId];
    }

    function setWithdrawAddress ( address _withdrawAddress )
    public
    
    {
        require(msg.sender==owner,"Only owner can set Parameters");
        require(_withdrawAddress != address(0),"Zero Address Error!");

        
        deleteMaxPendingTx();
       
        uint256 transactionId = _transactionIdx++;

        Transaction memory transaction;
        
        transaction.withdrawAddress_ = _withdrawAddress;
        transaction.timestamp = block.timestamp;
        transaction.signatureCount = 0;
        _transactions[transactionId]=transaction;
        _pendingTransactions.push(transactionId);

        emit TransactionCreated(_withdrawAddress,  block.timestamp, transactionId);
        emit IDOEvents(block.timestamp,msg.sender, "setWithDrawAddress");
    }

    // function setTimestamps (uint256 startTime_,uint256 endSellTime_,
    //                         uint256 protectTime_, uint256 claimTime_)
    //             public
                
    //             {
    //                 require(msg.sender==owner,"Only owner can set Parameters");
    //                 startTimestamp = startTime_;
    //                 endSellTimestamp = endSellTime_;
    //                 protectTimestamp = protectTime_;
    //                 claimTimestamp = claimTime_;
    //                 emit IDOEvents(block.timestamp, msg.sender, "setTimeStamps");
    //             }


    function setProjectCoinAddress (address projectCoinAddress_)
    public 
    {
        require(msg.sender==owner,"Only owner can set Parameters");
        projectCoinAddress = projectCoinAddress_;
        emit IDOEvents(block.timestamp, msg.sender, "set projectCoinAddress");
    }
    

    // function  setParameters (string memory  _projectName,
    //                          address _investCoinAddress,
    //                          address _publicKey,
    //                          uint256 _projectCoinPrice,
    //                          uint _raiseStatus)
    // public 
    
    // {
        
    //     require(msg.sender==owner,"Only owner can set Parameters");
    //    	name = _projectName;
    //     investCoinAddress = _investCoinAddress;
    //     publicKey = _publicKey;
    //     projectCoinPrice = _projectCoinPrice;
    //     raiseStatus = _raiseStatus;
    //     emit IDOEvents(block.timestamp, msg.sender, "set Parameters");
    // }


    function getProjectInfo (address _tokenAddress)
    public 
    view 
    returns ( projectInfoGet memory )
    {
        uint256 currentStatus = 0;
        if (block.timestamp < startTimestamp) currentStatus = 0;
        else if (block.timestamp < endSellTimestamp) currentStatus = 1;
        else if (block.timestamp < protectTimestamp) currentStatus = 2;
        else if (block.timestamp < claimTimestamp) currentStatus = 3;
        else  currentStatus = 4;

        projectInfoGet memory getInfo = 
            projectInfoGet({
                 price:projectCoinPrice,
                 targetAmount:investTargetAmount,
                 currentAmount:investedAmount[_tokenAddress],
                 participants:investors.length,
                 raiseCoinAddress:projectCoinAddress,
                 moneyAddress:investCoinAddress,
                 vip1Allocation:VIPLimit[1],
                 vip2Allocation:VIPLimit[2],
                 vip3Allocation:VIPLimit[3],
                 vip1Percent:VIPPerLimit[1],
                 vip2Percent:VIPPerLimit[2],
                 vip3Percent:VIPPerLimit[3],
                 raiseStatus:currentStatus,
                 startTime:startTimestamp,
                 endSellTime:endSellTimestamp,
                 protectTime:protectTimestamp,
                 claimTime: claimTimestamp,
                 vip1CurrentAmount: VIPAmount[_tokenAddress][1],
                 vip2CurrentAmount: VIPAmount[_tokenAddress][2],
                 vip3CurrentAmount: VIPAmount[_tokenAddress][3]

            });
        return getInfo;
    }

    function getVIPAmount(address tokenAddress_)
    public 
    view
    returns (uint256,uint256,uint256)
    {
        return(VIPAmount[tokenAddress_][1],VIPAmount[tokenAddress_][2],VIPAmount[tokenAddress_][3]);
    }

    function getUserVIPAmount(address tokenAddress_, address userAddress_)
    public 
    view
    returns (uint256,uint256,uint256)
    {
        return(userVIPAmount[userAddress_][tokenAddress_][1],
               userVIPAmount[userAddress_][tokenAddress_][2],
               userVIPAmount[userAddress_][tokenAddress_][3]
               );
    }
    function setProjectInfo ( 
        uint256 timestamp,
        bytes32 nonce, 
        uint8 userLevel,
        bytes32 message,
        bytes memory signature,
        projectInfoSet calldata info)
    public 
    validOwner
    nonReentrant 
    notContract
    {
                require(block.timestamp < startTimestamp,"Can not set parameters after project start");
                bytes32 challenge = getChallenge(timestamp, nonce,userLevel, msg.sender);
                require(message == challenge,"message not correct!");
                bool isVerified = verified(publicKey,challenge, signature);
                require(isVerified, "Verify Error!");

                projectCoinPrice=info.price;
                investTargetAmount = info.targetAmount;
                projectCoinAddress=info.raiseCoinAddress;
                investCoinAddress=info.moneyAddress;
                VIPLimit[1]=info.vip1Allocation;
                VIPLimit[2]=info.vip2Allocation;
                VIPLimit[3]=info.vip3Allocation;
                VIPPerLimit[1] = info.vip1Percent;
                VIPPerLimit[2]= info.vip2Percent;
                VIPPerLimit[3] = info.vip3Percent;
                raiseStatus=info.raiseStatus;
                startTimestamp = info.startTime;
                endSellTimestamp = info.endSellTime;
                protectTimestamp = info.protectTime;  
                claimTimestamp = info.claimTime;  
    }


    //invest with sign
    function investInWithVerify(
        uint256 timestamp,
        bytes32 nonce, 
        uint8 userLevel,
        bytes32 message,
        bytes memory signature,
        address _tokenAddress, 
        uint256 tokenAmounts_
        )
        nonReentrant 
        notContract
        public  
        {
            bytes32 challenge = getChallenge(timestamp, nonce,userLevel, msg.sender);
            require(message == challenge,"message not correct!");
            bool isVerified = verified(publicKey,challenge, signature);
            require(isVerified, "Verify Error!");
            require(block.timestamp - timestamp <2 minutes, "timestamp Error!");
            require(investCoinAddress == _tokenAddress, "invest Coin Not Correct!");
            require(userLevel == 1 || userLevel ==2 || userLevel ==3, "User Level Error!");

            require(block.timestamp >= startTimestamp && block.timestamp <endSellTimestamp, "you should invest after the IDO is in Selling ");
            require(_tokenAddress != address(0),"Token not support Now"); 

            require(tokenAmounts_ > 0,"you should deposit some coins of this token");  
            require(investedAmount[_tokenAddress] + tokenAmounts_ <= investTargetAmount, "Target Amount Over Flow!" );
            require(tokenAmounts_ % projectCoinPrice ==0, "invest amount should be integral dividen by the token Price"); 
            

            Investor storage investor = investorByAddress [msg.sender];
            
            
            require(investor.investedCoinAmount + tokenAmounts_ <= VIPLimit[userLevel] * 10 ** decimals,"Level Limit Over Flow ");
            require((VIPAmount[_tokenAddress][userLevel]+ tokenAmounts_)*100/investTargetAmount <= VIPPerLimit[userLevel], "Level Percent Limit Over Flow!");
            
            if(investor.investorAddress == msg.sender){
                require(investor.investCoinAddress == _tokenAddress, "The Coin Address incorrect!");
                require(investor.claimedProjectCoinAmount == 0,"Can not invest after claimed coins!");
                require(investor.refundedCoinAmount == 0, "You had already Refunded out!");

                investor.investedCoinAmount += tokenAmounts_;
                investor.investedAt = block.timestamp;
                
                uint256 index = investorIndex[msg.sender];
                investors[index].investedCoinAmount += tokenAmounts_;
                investors[index].investedAt = block.timestamp;


            }else {
                Investor memory inv;
                inv.investCoinAddress = _tokenAddress;
                inv.investorAddress = payable(msg.sender);
                inv.investedCoinAmount += tokenAmounts_;
                inv.investedAt = block.timestamp;
                investorByAddress[msg.sender]=inv;
                investors.push(inv);

                uint256 index = investors.length - 1;
                investorIndex[msg.sender] = index;
            }
            
            investedAmount[_tokenAddress] += tokenAmounts_;
            VIPAmount[_tokenAddress][userLevel]+=tokenAmounts_;
            userVIPAmount[msg.sender][_tokenAddress][userLevel]+=tokenAmounts_;

            IERC20(_tokenAddress).safeTransferFrom(msg.sender,address(this), tokenAmounts_);  
            emit IDOEvents(block.timestamp, msg.sender, "invest Coin");
            emit IDOStatusChange(_tokenAddress, tokenAmounts_, msg.sender, string(abi.encodePacked("Invest ",userLevel)));
            
        }
    //get Challenge
    function getChallenge(uint256 timestamp,
                              bytes32 nonce, 
                              uint8 userLevel,
                              address userAddress
                             ) private  returns (bytes32){
        chainId = block.chainid;
        bytes32 challenge = keccak256(abi.encodePacked( userAddress, timestamp, nonce, userLevel, chainId));
       
        return challenge;   
    }
    

    function verifiedOld(
        address signer,
        bytes32 message,
        bytes memory signature
    ) private pure returns (bool)
    {
        
        (bytes32 r, bytes32 s, uint8 v) = splitSignature(signature);
        bytes32 ethSignedMessageHash = getEthSignedMessageHash(message);
        address recovered = ecrecover(ethSignedMessageHash, v, r, s);
        return recovered == signer;
    }

    function verified(
        address expectedSigner,
        bytes32 messageHash,
        bytes memory signature
    ) public  pure returns (bool) {     
       
        address recoveredSigner = ECDSA.recover(messageHash, signature);
        require(recoveredSigner == expectedSigner, "Invalid signature");

        bytes32 r;
        bytes32 s;
        uint8 v;
        assembly {
            r := mload(add(signature, 32))
            s := mload(add(signature, 64))
            v := byte(0, mload(add(signature, 96)))
        }
        require(ecrecover(messageHash, v, r, s) == expectedSigner, "Invalid signature malleability");

        return true;
    }

    function getEthSignedMessageHash(bytes32 _messageHash) private  pure returns (bytes32) {
      
        return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", _messageHash));
    }

    function splitSignature(bytes memory sig)
    internal
    pure
    returns (bytes32 r, bytes32 s, uint8 v)
    {
        require(sig.length == 65, "invalid signature length");

        assembly {
            r := mload(add(sig, 32))
            s := mload(add(sig, 64))   
            v := byte(0, mload(add(sig, 96)))
        }

        if (v < 27) {
            v += 27;
        }
    }

    function refundOut(
        uint256 timestamp,
        bytes32 nonce, 
        uint8 userLevel,
        bytes32 message,
        bytes memory signature,
        address tokenAddress_) 
        nonReentrant 
        notContract
        public {
        
            bytes32 challenge = getChallenge(timestamp, nonce,userLevel, msg.sender);
            require(message == challenge,"message not correct!");
            bool isVerified = verified(publicKey,challenge, signature);
            require(isVerified, "Verify Error!");

            require(investCoinAddress == tokenAddress_, "invest Coin Not Correct!");
            require(tokenAddress_ != address(0),"Token not support Now");  
        
            Investor storage invest = investorByAddress[msg.sender];

            require(msg.sender==invest.investorAddress,"Only the Investor can refund tokens!");
            require(invest.claimedProjectCoinAmount == 0,"Can not refund after claim coins!");
            require(invest.refundedCoinAmount == 0, "You had already Refunded out!");
            
            require(block.timestamp >= protectTimestamp && block.timestamp < claimTimestamp, "you should refund after the IDO is in protect ");
            

            IERC20(tokenAddress_).safeTransfer(invest.investorAddress, invest.investedCoinAmount); 

            investedAmount[tokenAddress_] -= invest.investedCoinAmount;
            refundedAmount[tokenAddress_] += invest.investedCoinAmount;


            uint256 index = investorIndex[msg.sender];
            investors[index].investedCoinAmount = 0;
            investors[index].refundedCoinAmount = invest.investedCoinAmount;
            investors[index].refundedAt = block.timestamp;
            
        
            //VIPAmount[tokenAddress_][userLevel] -= invest.investedCoinAmount;
            require(userVIPAmount[msg.sender][tokenAddress_][1]+userVIPAmount[msg.sender][tokenAddress_][2]+userVIPAmount[msg.sender][tokenAddress_][3]
                    == invest.investedCoinAmount, "User VIP Amount Error!");

            VIPAmount[tokenAddress_][1] -= userVIPAmount[msg.sender][tokenAddress_][1];
            VIPAmount[tokenAddress_][2] -= userVIPAmount[msg.sender][tokenAddress_][2];
            VIPAmount[tokenAddress_][3] -= userVIPAmount[msg.sender][tokenAddress_][3];

            userVIPAmount[msg.sender][tokenAddress_][1] = 0;
            userVIPAmount[msg.sender][tokenAddress_][2] = 0;
            userVIPAmount[msg.sender][tokenAddress_][3] = 0;
            
            invest.refundedCoinAmount = invest.investedCoinAmount;
            invest.investedCoinAmount = 0;
            invest.refundedAt = block.timestamp; 

            emit IDOEvents(block.timestamp, msg.sender, "Refund Coin");
            emit IDOStatusChange(tokenAddress_, invest.investedCoinAmount, msg.sender, string(abi.encodePacked("Refund ",userLevel)));
        }

     /*
     * *@dev the project Coin Deposit
     * 
     */
    function depositProjectCoin(
        uint256 timestamp,
        bytes32 nonce, 
        uint8 userLevel,
        bytes32 message,
        bytes memory signature,
        address projectCoinAddress_, uint256 depositAmount) 
    payable
    public
    //onlyOwner 
    {
        
        bytes32 challenge = getChallenge(timestamp, nonce,userLevel, msg.sender);
        require(message == challenge,"message not correct!");
        bool isVerified = verified(publicKey,challenge, signature);
        require(isVerified, "Verify Error!");


        
        require(projectCoinAddress == projectCoinAddress_, "ProjectCoinAddress Not the same as before");
       
        IERC20(projectCoinAddress).safeTransferFrom(msg.sender,address(this), depositAmount);  

        projectCoinAmount[projectCoinAddress_] = IERC20(projectCoinAddress_).balanceOf(address(this));
       
        emit IDOEvents(block.timestamp, msg.sender, "deposit Project Coin");
        emit IDOStatusChange(projectCoinAddress, depositAmount, msg.sender, string(abi.encodePacked("Deposit ",userLevel)));
    }

    function getProjectCoinAmount (address projectCoinAddress_)
    public 
    view 
    returns (uint256)
    {
       return  IERC20(projectCoinAddress_).balanceOf(address(this));
    }
    /*
    * @projectCoinAddress_ the Issued Coin Contract Address 
    * @ claimAmount the Amount of ProjectCoin want to claim out
    */
    function claimProjectCoin(
        uint256 timestamp,
        bytes32 nonce, 
        uint8 userLevel,
        bytes32 message,
        bytes memory signature,
        address projectCoinAddress_) 
        nonReentrant 
        notContract
        public {
        
        bytes32 challenge = getChallenge(timestamp, nonce,userLevel, msg.sender);
        require(message == challenge,"message not correct!");
        bool isVerified = verified(publicKey,challenge, signature);
        require(isVerified, "Verify Error!");

        // require(isIssued==true,"Token not issued!");
        Investor storage invest = investorByAddress[msg.sender];

        require(projectCoinAddress==projectCoinAddress_, "The Project Coin Address is incorrect");
        require(msg.sender==invest.investorAddress,"Only the Investor can Claim tokens!");
        //require(raiseStatus == 3 || raiseStatus == 4,"You can only Claim during the Protected or Claim status");
        require(block.timestamp >= protectTimestamp, "you should refund after the IDO is in protect ");
        require(invest.refundedCoinAmount == 0, "You had already Refunded out!");
        require(invest.claimedProjectCoinAmount == 0, "You had already Claimed out!");
        uint256 claimAmount = invest.investedCoinAmount * 10 ** decimals / projectCoinPrice ; 
        require(IERC20(projectCoinAddress_).balanceOf(address(this))>=  claimAmount, "Project Coin amount insufficient");

        //require(IERC20(projectCoinAddress_).approve(address(this),  claimAmount), "Approve has failed"); 
        IERC20(projectCoinAddress_).safeTransfer(invest.investorAddress, claimAmount);     
        
        invest.claimedProjectCoinAmount +=claimAmount;
        invest.claimedAt = block.timestamp;

        uint256 index = investorIndex[msg.sender];
        investors[index].claimedProjectCoinAmount += claimAmount;
        investors[index].claimedAt = block.timestamp;   
        
        claimedAmount[projectCoinAddress_] +=  claimAmount;
        projectCoinAmount[projectCoinAddress_] = IERC20(projectCoinAddress_).balanceOf(address(this));

        emit IDOEvents(block.timestamp, msg.sender, "Claim");
        emit IDOStatusChange(projectCoinAddress_, claimAmount, msg.sender,  string(abi.encodePacked("Claim ",userLevel))); 
    }

    function getInvestsByOwner(address who_)
    external
    view
    returns(Investor memory )
    {
    	Investor memory invest=investorByAddress[who_];
    	return invest;
    }

    function getInvestors()
    external
    view
    returns (Investor [] memory )
    {
        return investors;
    }

    function getCurrentAmounts(address tokenAddress_, address projectCoinAddress_)
    external 
    view 
    returns (uint256, uint256, uint256,uint256){
        return (investedAmount[tokenAddress_],refundedAmount[tokenAddress_],claimedAmount[projectCoinAddress_], investTargetAmount);
    }
    
    function getCoinBalance(address tokenAddress_) external view returns(uint) {
     return IERC20(tokenAddress_).balanceOf(address(this));
    }

    function getsProjectInfo(address _tokenAddress,address projectCoinAddress_) 
     external 
     view 
     returns( string memory,address,uint256,uint256,uint256,uint256,uint256) {

     return (name,projectCoinAddress,projectCoinPrice,
             investedAmount[_tokenAddress],
             refundedAmount[_tokenAddress],
             claimedAmount[projectCoinAddress_],
             IERC20(projectCoinAddress_).balanceOf(address(this)));
   }
   /**
    ** withdraw projectCoin or investCoin by manager;
    ** After the end time;
    **/
      
   function withdrawAllFunds(address tokenAddress_, uint256 amount_) 
    external
    nonReentrant 
    notContract 
    withdrawAddressOnly() {
        //uint256 balance = IERC20(tokenAddress_).balanceOf(address(this));
        require(investCoinAddress == tokenAddress_ || projectCoinAddress == tokenAddress_, "Coin Address Not Correct!");
        require(block.timestamp - claimTimestamp >= 3 days, "Withdraw Fund Until 72 hours after Claim ");

        if(tokenAddress_ == investCoinAddress){
            require(investedAmount[tokenAddress_] >= amount_, "balance insufficent!");
            investedAmount[tokenAddress_] -= amount_;
            refundedAmount[tokenAddress_] += amount_;
            emit IDOStatusChange(tokenAddress_, amount_, msg.sender, "Manager Withdraw invest Coins");
            }
        else if(tokenAddress_ == projectCoinAddress){
            uint256 investAmount =  investedAmount[investCoinAddress];
            uint256 claimAmount = claimedAmount[projectCoinAddress];
            require((investAmount * 10 ** decimals / projectCoinPrice - claimAmount) ==0,"Some others not claimed, can not withdraw so many!");


            projectCoinAmount[tokenAddress_] -= amount_;
            claimedAmount[tokenAddress_] += amount_;
            emit IDOStatusChange(tokenAddress_, amount_, msg.sender, "Manager Withdraw invest Coins");
            }
        else 
            revert("withDraw TokenAddress ERROR");
        
        IERC20(tokenAddress_).safeTransfer(msg.sender, amount_);

   }

   modifier withdrawAddressOnly() {
     require(msg.sender == withdrawAddress, 'only withdrawer can call this');
     _;
   }    
   //not contract address
    modifier notContract() {
    require((!_isContract(msg.sender)) && (msg.sender == tx.origin), "contract not allowed");
    _;
    }

    function _isContract(address addr) internal view returns (bool) {
        uint256 size;
        assembly {
            size := extcodesize(addr)
        }
        return size > 0;
    }
}